package dp;

/**
 * No.338 比特位计数 counting bits
 *
 * @author Sean Yu
 * @date 2020/12/1 10:06
 */
public class No338 {
}


/**
 * 常规的做法：
 * 对每个数而言，先将数转为2进制，然后统计1的个数
 * <p>
 * DP解法：
 * 1. 分析最后一步
 * 首先一个数被转成2进制的过程是不停的模2求余，然后将原数除以2（或者右移1位），直到该数为0
 * 比如4求二进制
 * 4%2 = 0，4 >> 1 = 2
 * 2%2 = 0，2>>1 = 1
 * 1%2 == 1，1 >> 1 = 0 终止
 * 所以4的二进制是100
 * <p>
 * 可以看到，4包含1的个数 = （4除以2）包含1的个数 + （4%2）包含1的个数
 * <p>
 * 如果是n， 那么n包含1的个数 = （n/2 取下整）包含1的个数 + （n%2）包含1的个数
 * 子问题就变成了，求n/2 取下整 包含1的个数
 * <p>
 * 2.确定状态转移方程
 * 假设dp(i)表示i的二进制里1的个数，那么有
 * dp(i) = dp(i >> 1) + i%2 == 0 ? 0:1
 * 或者
 * dp(i) = dp( (int)(i/2) ) + i%2 == 0 ? 0:1
 * <p>
 * 3.确定初始条件 和 边界情况
 * dp(0) = 0
 * <p>
 * 4.计算顺序： 从小到大
 */
class Solution338 {
    public int[] countBits(int num) {
        //题目保证num非负
        int[] dp = new int[num + 1];
        for (int i = 1; i <= num; ++i) {
            dp[i] = dp[i >> 1] + (i % 2 == 0 ? 0 : 1);
        }
        return dp;
    }
}