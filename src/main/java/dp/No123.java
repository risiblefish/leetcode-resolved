package dp;

/**
 * 123. 买卖股票的最佳时机 III
 *
 * @author Sean Yu
 */
public class No123 {
    public static void main(String[] args) {
        System.out.println(new Solution123().maxProfit(new int[]{2,1,4,5,2,9,7}));
    }
}


/**
 * 1.分析最后一步
 * 由于最多只能买卖2次，所以我们无法通过简单的一维数组来确定状态，
 * 比如，用dp(i)来表示第i天的最大收益，那么dp(i)和dp(i-1)之间的关系是不能直接推导出的。
 * 这种情况，就要把先决条件加入状态里。
 * <p>
 * 由于至多2次买卖，所以可以分成5个阶段：
 * <p>
 * 阶段0： 第一次买之前
 * 阶段1： 当天买 到 第一次卖之前 (持有股票)
 * 阶段2： 第一次卖之后 到 第二次买之前
 * 阶段3： 当天买 到 第二次卖之前（持有股票）
 * 阶段4： 第二次卖之后
 * <p>
 * 且最优解一定是阶段0，2，4中某一个阶段，不能为阶段1，3。
 * <p>
 * 2. 状态转移方程
 * <p>
 * 假设dp[i][k]表示前i天阶段k的最大收益，那么有：
 * 令gap = p[i-1] - p[i-2]
 *
 * （0）阶段0只能由1个阶段转换而来：
 *   dp[i][0] = dp[i-1][0]
 *
 * （1）阶段1可以由2个阶段转换而来：
 *  I.第一次买之前（手里没股票） 到 今天买并持有 （前一天是阶段0 -> 当天是阶段1， 收益不增加）
 *  II.第一次买了之后到前一天都持有（手里有股票），今天选择继续持有 （前一天是阶段1 -> 今天是阶段1，因为多持有了1天，所以 多的收益是 当天的价格 - 前一天的价格）
 *  dp[i][1] = max { dp[i-1][0] , dp[i-1][1] + gap }
 *
 * （2）阶段2可以由2个阶段转换而来：
 *  I. 第一次卖之后到前一天都没有买入（手里没股票），当天选择继续不买入 （前一天是阶段2 -> 今天是阶段2，因为手里没有股票，所以收益不增加）
 *  II. 第一次买之后到前一天扔持有（手里有股票），当天选择卖掉 （前一天是阶段1 -> 今天是阶段2，因为我们把持有股票度过天数的情况仍计算了收益，所以这里多的收益是 当天的价格 - 前一天的价格）
 *  dp[i][2] = max { dp[i-1][2] , dp[i-1][1] + gap }
 *
 *  (3)阶段3可以由3个阶段转换而来：
 *  I. 第一次卖掉股票之后到前一天都不买（手里没股票），今天买股票（前一天是阶段2 -> 今天是阶段3， 收益不增加）
 *  II. 第一次买的股票到前一天都持有（手里有股票），今天卖掉，再立马买股票 （前一天是阶段1 -> 今天是阶段3 ，因为我们把持有股票度过天数的情况仍计算了收益，所以这里多的收益是 今天的价格 - 前一天的价格）
 *  III. 第二次买的股票到前一天都持有（手里有股票），今天选择继续持有（前一天是阶段3 -> 今天是阶段3 ，因为多持有了1天，所以 多的收益是 当天的价格 - 前一天的价格 ）
 *  dp[i][3] = max { dp[i-1][2] , dp[i-1][1] + gap , dp[i-1][3] + gap }
 *
 * （4）阶段4可以由2个阶段转换而来：
 *  I. 第二次卖掉股票之后到前一天都不买（手里没股票），今天继续不买 （前一天是阶段4 -> 今天是阶段4）
 *  II. 第二次买入股票之后到前一天都持有（手里有股票），今天卖掉 （前一天是阶段3 -> 今天是阶段4）
 *  dp[i][4] = max { dp[i-1][4] , dp[i-1][3] + gap }
 *
 *  ps : 如果还是不理解上面的方程，可以通过画 阶段之间转换 的树状图来分析（这样可以保证不遗漏每一种情况）
 *
 *  这道题的难点在于确定状态，比如把连续持仓算作收益，把买入不算作亏损。
 *
 *  最后要求的结果，就是dp(n)里阶段0，2，4里的最大值
 *
 * <p>
 * 3. 初始条件和边界情况
 * <p>
 * dp[0][0~4] = 0
 *
 * 4. 计算顺序： 从小到大
 */
class Solution123 {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }

        int n = prices.length;
        int[][] dp = new int[n + 1][5];

        for (int i = 1; i <= n; i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = dp[i - 1][0];
            dp[i][2] = dp[i - 1][2];
            dp[i][3] = dp[i - 1][2];
            dp[i][4] = dp[i - 1][4];
            //如果有前一天，就选最大值
            if (i - 2 >= 0) {
                int gap = prices[i - 1] - prices[i - 2];
                dp[i][1] = Math.max(dp[i][1], dp[i - 1][1] + gap);
                dp[i][2] = Math.max(dp[i][2], dp[i - 1][1] + gap);
                dp[i][3] = Math.max(dp[i][3], Math.max(dp[i - 1][1] + gap, dp[i - 1][3] + gap));
                dp[i][4] = Math.max(dp[i][4], dp[i - 1][3] + gap);
            }
        }

        int temp = Math.max(dp[n][0], dp[n][2]);
        return Math.max(temp, dp[n][4]);
    }
}
